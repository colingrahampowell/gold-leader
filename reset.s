; Startup code for cc65/ca65
; from doug fraker: nesdoug.com

.import _main
.export __STARTUP__:absolute=1
.export _WaitFrame, _UpdateInput
.exportzp _FrameCount, _JoyPad1, _PrevJoyPad1

; Linker generated symbols
.import __STACK_START__, __STACKSIZE__
.include "zeropage.inc"
.import initlib, copydata

;variables
INPUT_1 = $4016

.segment "ZEROPAGE"

; frame handling: reserve 1 byte:
_FrameCount: 	.res 1
frame_done:		.res 1

; input handling: reserve 1 byte each:
_JoyPad1:		.res 1
_PrevJoyPad1:	.res 1
tmp:			.res 1		; temp var in button reading routing

.segment "HEADER"

    .byte $4e,$45,$53,$1a	; 'NES' - start of every .nes file
	.byte 01				
	.byte 01
	.byte 00
	.byte 00
	.res 8,0


.segment "STARTUP"

start:
	sei
	cld
	ldx #$40
	stx $4017
	ldx #$ff
	txs
	inx
	stx $2000
	stx $2001
	stx $4010
:
	lda $2002
	bpl :-
	lda #$00
Blankram:			;puts zero in all CPU RAM
	sta $00, x
	sta $0100, x
	sta $0200, x
	sta $0300, x
	sta $0400, x
	sta $0500, x
	sta $0600, x
	sta $0700, x
	inx
	bne Blankram
	
:
	lda $2002
	bpl :-

Isprites:
	jsr Blanksprite
	lda #$00		;pushes all sprites from 200-2ff
	sta $2003		;to the sprite memory
	lda #$02
	sta $4014
	
	jsr ClearNT		;puts zero in all PPU RAM

MusicInit:			;turns music channels off
	lda #0
	sta $4015
	
	lda #<(__STACK_START__+__STACKSIZE__)
    sta	sp
    lda	#>(__STACK_START__+__STACKSIZE__)
    sta	sp+1      	; Set the c stack pointer
	
	jsr	copydata
	jsr	initlib
	
	lda $2002		;reset the 'latch'

	jmp _main		;jumps to main in c code


;
; Proc: BlankSprite
; Description: Puts all sprites off screen
;

_Blanksprite:
Blanksprite:
	ldy #$40
	ldx #$00
	lda #$f8
Blanksprite2:		;puts all sprites off screen
	sta $0200, x
	inx
	inx
	inx
	inx
	dey
	bne Blanksprite2
	rts

;
; Proc: ClearNT (internal) 
; DescriptioN: zeroes PPU RAM
;

_ClearNT:
ClearNT:
	lda $2002
	lda #$20
	sta $2006
	lda #$00
	sta $2006
	lda #$00	;tile 00 is blank
	ldy #$10
	ldx #$00
BlankName:		;blanks screen
	sta $2007
	dex
	bne BlankName
	dey
	bne BlankName
	rts

; 
; Proc: WaitFrame (exported / visible to C)
; Description: Waits for frame to finish: this hangs on a loop 
; until NMI generated by vblank, at which point frame_done is set
; to zero.
;

_WaitFrame:
	inc frame_done
@loop:
	lda frame_done		; load frame_done - set to zero in NMI
	bne @loop			; will branch if frame_done not 0
	rts


; 
; Proc: UpdateInput (external / visible in C)
; Description: checks button state for transition
;

_UpdateInput:
	; store prev input state
	lda _JoyPad1
	sta _PrevJoyPad1
	 
	jsr ReadJoy

; read twice: DMC DMA interference 
@mismatch:
	; load joypad1 state, store in tmp
	lda _JoyPad1
	sta tmp

	; read input again, then load JoyPad1
	; then, compare to prev-read value
	; continue until both are identical

	jsr ReadJoy
	lda _JoyPad1
	cmp tmp

	bne @mismatch

	rts


;
; Proc: ReadJoy (internal)
; Description: Read JoyPad for player 1
;

ReadJoy:
	; strobe input (write 1, then 0 to sync input)
	ldx #$01
	stx INPUT_1
	dex		
	stx INPUT_1

	ldy #$08			; put 8 in y register

loop:
	lda INPUT_1
	and #$01		; ignore other than controller (button info stored in bit 0)

	cmp #$01		; set carry iff nonzero
	rol _JoyPad1	; put carry into bit 0, put bit 7 into carry

	dey				; decrement y
	bne loop		; branch back to start if not finished reading
	
	rts				; return from subroutine


; nmi: non-maskable interrupt

nmi:
	; push registers to stack
	pha 	; push accumulator
	txa		; transfer x to a
	pha		; push x (stored in a)
	tya		; transfer y to a
	pha		; push y (stored in a)

	inc _FrameCount	; increment frame counter	

	; more PPU-related stuff...

	; free _WaitFrame
	lda #$0
	sta frame_done

	; pop registers stored on stack back into place
	pla	
	tay		; y stored last, popped first
	pla
	tax		; x next
	pla		; finally, pop a

irq:
    rti

.segment "RODATA"

;none yet

.segment "VECTORS"

    .word nmi	;$fffa vblank nmi
    .word start	;$fffc reset
   	.word irq	;$fffe irq / brk


.segment "CHARS"

	.incbin "Alpha.chr"
